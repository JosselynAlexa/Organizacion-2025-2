TALLER 11
section .data
msg db "Resultado: ", 0
len equ $ - msg
msg_error db "ERROR: Division por Cero!", 0ah ; Nuevo mensaje de
error
len_error equ $ - msg_error

newline db 10, 0
lenNL equ $ - newline
section .bss
resultado resb 1
section .text
global _start
_start:
; ============================
; Números hardcoded
; ============================
mov al, '8' ; primer número (ASCII)
sub al, '0' ; AL = 8
mov bl, '0' ; segundo número (ASCII) -- (Cambiado a '0' para
probar el manejo)
sub bl, '0' ; BL = 0
; ============================
; SIMULACIÓN DE MANEJO DE INTERRUPCIÓN 0x00
; ============================
cmp bl, 0 ; Compara el divisor (BL) con 0
je manejar_division_cero ; Si BL es CERO (ZF=1), salta a la rutina de
manejo de error.
; Si no hay error, ejecuta la división normal
jmp division_normal
; --- Rutina de Manejo de Error (Simula la ISR) ---
manejar_division_cero:
; (Imprimir "ERROR: Division por Cero!")
mov eax, 4
mov ebx, 1
mov ecx, msg_error ; Dirección del mensaje de error
mov edx, len_error
int 0x80
; Salir con código de error (simula el final de la ISR)

mov eax, 1
mov ebx, 1 ; Código de error 1
int 0x80
; --- División Normal (Se ejecuta si BL != 0) ---
division_normal:
xor ah, ah ; Limpiar AH para div
div bl ; División AL / BL
; ============================
; Convertir resultado a ASCII
; ============================
add al, '0'
mov [resultado], al
; ============================
; Imprimir "Resultado: "
; ============================
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, len
int 0x80
; ============================
; Imprimir el resultado
; ============================
mov eax, 4
mov ebx, 1
mov ecx, resultado
mov edx, 1
int 0x80

; ============================
; Imprimir salto de línea
; ============================
mov eax, 4
mov ebx, 1
mov ecx, newline
mov edx, lenNL

int 0x80
; ============================
; Salir
; ============================
mov eax, 1
xor ebx, ebx
int 0x80
